/* Carmen Clock p5.js global mode (window.*) + secret "new" button
*
* Fixes "no canvas" issues by binding setup/draw/etc to window explicitly.
* - Tap/click shows "new" button; hides after 10s inactivity
* - Clicking "new" changes the style variant (new seeded composition)
* - Time stays live and correct (we never override Date())
* - Day/Night background via geolocation + sunrise-sunset.org (fallback)
*/

/* global createCanvas, windowWidth, windowHeight, angleMode, textFont,
background, width, height, push, pop, translate, scale, randomSeed,
random, noStroke, fill, triangle, rectMode, rect, beginShape, vertex,
endShape, CLOSE, rotate, stroke, strokeWeight, strokeCap, SQUARE,
line, cos, sin, map, textAlign, CENTER, textSize, text, millis,
createButton
*/

(function () {
const CONFIG = {
dayBg: "#F4F1EA",
nightBg: "#0B0B0C",
palette: ["#0B0B0C", "#E4241C", "#0A8F4E", "#F2C200"],

centerRadius: 36,
orbitRadius: 140,
dailyShapeSize: 260,
rayMinLen: 160,
rayMaxLen: 360,
rayMinWeight: 4,
rayMaxWeight: 18,

clockFontSize: 26,
stampFontSize: 16,

uiHideAfterMs: 10000,
};

let isDaylight = true;
let lastSunFetchDayKey = null;

// UI state
let newBtn = null;
let uiHideTimer = null;
let lastActivityMs = 0;

// Variant state
let styleVariant = 0;
let variantSalt = 0;

// ----------------------
// p5 lifecycle (bound to window)
// ----------------------

window.setup = function () {
createCanvas(windowWidth, windowHeight);
angleMode("degrees");
textFont("system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial");

// Restore variantSalt (optional persistence)
try {
const saved = localStorage.getItem("carmenClockVariantSalt");
variantSalt = saved ? parseInt(saved, 10) : 0;
} catch (e) {
variantSalt = 0;
}

// Create secret button
newBtn = createButton("new");
newBtn.addClass("p5DomButton");
styleSecretButton();
newBtn.hide();

newBtn.mousePressed(function () {
registerActivity();
bumpVariant();
});

registerActivity();
refreshDaylightStatus();
};

window.draw = function () {
const now = new Date();
const dayKey = `${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(
now.getDate()
)}`;

if (lastSunFetchDayKey !== dayKey) refreshDaylightStatus();

background(isDaylight ? CONFIG.dayBg : CONFIG.nightBg);

const cx = width / 2;
const cy = height / 2;
const minDim = Math.min(width, height);
const s = minDim / 900;

push();
translate(cx, cy);
scale(s);

drawDailyCenterShape(dayKey);
drawHourlyRays(dayKey, now.getHours());
drawMinuteOrbiter(now);

pop();

drawClockStamp(now);

// keep button readable as bg flips
styleSecretButton();
positionSecretButton();
};

window.windowResized = function () {
// resizeCanvas exists in p5 global mode
if (typeof window.resizeCanvas === "function") {
window.resizeCanvas(windowWidth, windowHeight);
}
positionSecretButton();
};

// ----------------------
// Input â†’ activity tracking (secret button visibility)
// ----------------------

window.mousePressed = function () {
registerActivity();
};

window.touchStarted = function () {
registerActivity();
// prevent page scroll / double-tap zoom weirdness
return false;
};

window.mouseMoved = function () {
if (millis() - lastActivityMs > 500) registerActivity();
};

function registerActivity() {
lastActivityMs = millis();
showSecretButtonTemporarily();
}

function showSecretButtonTemporarily() {
if (!newBtn) return;

newBtn.show();
positionSecretButton();

if (uiHideTimer) clearTimeout(uiHideTimer);
uiHideTimer = setTimeout(function () {
newBtn.hide();
}, CONFIG.uiHideAfterMs);
}

function positionSecretButton() {
if (!newBtn) return;
newBtn.position(14, 14);
}

function styleSecretButton() {
if (!newBtn) return;

// NOTE: if your site has global CSS that affects buttons,
// p5's .style() writes inline styles that usually win.
newBtn.style("position", "fixed");
newBtn.style("z-index", "99999");
newBtn.style("background", "rgba(255,255,255,0.12)");
newBtn.style("color", isDaylight ? "#0B0B0C" : "#F4F1EA");
newBtn.style(
"border",
isDaylight
? "1px solid rgba(0,0,0,0.25)"
: "1px solid rgba(255,255,255,0.25)"
);
newBtn.style("padding", "8px 12px");
newBtn.style("border-radius", "10px");
newBtn.style("font-size", "14px");
newBtn.style("letter-spacing", "0.08em");
newBtn.style("text-transform", "uppercase");
newBtn.style("cursor", "pointer");
}

function bumpVariant() {
styleVariant = (styleVariant + 1) % 7;
variantSalt = (variantSalt + 1) % 1000000;
try {
localStorage.setItem("carmenClockVariantSalt", String(variantSalt));
} catch (e) {
// ignore
}
}

// ----------------------
// Drawing
// ----------------------

function drawDailyCenterShape(dayKey) {
const seed = hash32(`${dayKey}-V${styleVariant}-S${variantSalt}`);
randomSeed(seed);

const v = getVariantParams();

const x =
random(-CONFIG.centerRadius, CONFIG.centerRadius) * v.centerJitter;
const y =
random(-CONFIG.centerRadius, CONFIG.centerRadius) * v.centerJitter;

const fillCol = pickPalette(seed, 0, v.paletteShift);

noStroke();
fill(fillCol);

const size = CONFIG.dailyShapeSize * v.dailySize;

const shapeType =
v.shapeFamily === 0
? 0
: v.shapeFamily === 1
? 1
: Math.floor(random(0, 3));

if (shapeType === 0) {
push();
translate(x, y);
rotate(
v.allowTilt ? random(-14, 14) : snapAngle(random(0, 360), v.snapDegrees)
);
triangle(
-size * 0.45,
size * 0.35,
size * 0.5,
size * 0.1,
-size * 0.1,
-size * 0.55
);
pop();
} else if (shapeType === 1) {
push();
translate(x, y);
rotate(
v.allowTilt ? random(-12, 12) : snapAngle(random(0, 360), v.snapDegrees)
);
beginShape();
vertex(-size * 0.55, size * 0.35);
vertex(size * 0.55, size * 0.25);
vertex(size * 0.25, -size * 0.45);
vertex(-size * 0.65, -size * 0.25);
endShape(CLOSE);
pop();
} else {
push();
translate(x, y);
rotate(
v.allowTilt ? random(-10, 10) : snapAngle(random(0, 360), v.snapDegrees)
);
rectMode("center");
rect(0, 0, size * 0.95, size * 0.55);
pop();
}

if (random() < v.counterPlaneChance) {
const fillCol2 = pickPalette(seed, 1, v.paletteShift);
fill(fillCol2);

push();
translate(x, y);
rotate(
v.allowTilt ? random(-14, 14) : snapAngle(random(0, 360), v.snapDegrees)
);
rectMode("center");
rect(size * 0.18, -size * 0.12, size * 0.7, size * 0.18);
pop();
}
}

function drawHourlyRays(dayKey, hour) {
const v = getVariantParams();

const maxH = Math.max(0, Math.min(23, hour));
const step = v.hourStep;

for (let h = 0; h <= maxH; h += step) {
const seed = hash32(`${dayKey}-V${styleVariant}-S${variantSalt}-H${h}`);
randomSeed(seed);

const angleBase = map(h, 0, 23, -120, 240);
const a = angleBase + random(-6, 6) * v.rayAngleWobble;

const len = random(CONFIG.rayMinLen, CONFIG.rayMaxLen) * v.rayLength;
const w =
random(CONFIG.rayMinWeight, CONFIG.rayMaxWeight) * v.rayWeight;

const col = pickPalette(seed, 2, v.paletteShift);
stroke(col);
strokeWeight(w);
strokeCap(SQUARE);

const inner = 40;
const x1 = cos(a) * inner;
const y1 = sin(a) * inner;
const x2 = cos(a) * (inner + len);
const y2 = sin(a) * (inner + len);

line(x1, y1, x2, y2);
}
}

function drawMinuteOrbiter(now) {
const v = getVariantParams();

const minutes = now.getMinutes();
const seconds = now.getSeconds() + now.getMilliseconds() / 1000;
const minuteAngle = map(minutes + seconds / 60, 0, 60, -90, 270);

const seed = hash32(
`${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(
now.getDate()
)}-V${styleVariant}-S${variantSalt}-MIN`
);

const col = pickPalette(seed, 3, v.paletteShift);

noStroke();
fill(col);

const r = CONFIG.orbitRadius * v.orbitRadius;
const ox = cos(minuteAngle) * r;
const oy = sin(minuteAngle) * r;

push();
translate(ox, oy);
rotate(minuteAngle + 90);

const s = 44 * v.orbiterSize;
if (v.orbiterShape === 0) {
triangle(-s * 0.9, 0, s * 0.9, 0, 0, -s * 1.4);
} else {
beginShape();
vertex(0, -s * 1.2);
vertex(s * 0.9, 0);
vertex(0, s * 1.2);
vertex(-s * 0.9, 0);
endShape(CLOSE);
}
pop();
}

function drawClockStamp(now) {
const hh = now.getHours();
const mm = now.getMinutes();
const dateStr = `${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(
now.getDate()
)}`;
const timeStr = `${pad2(hh)}:${pad2(mm)}`;

const fg = isDaylight ? "#0B0B0C" : "#F4F1EA";

noStroke();
fill(fg);

textAlign(CENTER, CENTER);
textSize(CONFIG.clockFontSize);
text(timeStr, width / 2, height - 54);

textSize(CONFIG.stampFontSize);
text(dateStr, width / 2, height - 28);
}

// ----------------------
// Variant params
// ----------------------

function getVariantParams() {
switch (styleVariant) {
case 0:
return {
paletteShift: 0,
dailySize: 1.0,
centerJitter: 1.0,
rayLength: 1.0,
rayWeight: 1.0,
rayAngleWobble: 1.0,
orbitRadius: 1.0,
orbiterSize: 1.0,
orbiterShape: 0,
hourStep: 1,
allowTilt: true,
snapDegrees: 90,
shapeFamily: 2,
counterPlaneChance: 0.35,
};
case 1:
return {
paletteShift: 1,
dailySize: 0.92,
centerJitter: 0.85,
rayLength: 0.95,
rayWeight: 1.1,
rayAngleWobble: 0.7,
orbitRadius: 1.05,
orbiterSize: 0.95,
orbiterShape: 1,
hourStep: 1,
allowTilt: false,
snapDegrees: 90,
shapeFamily: 0,
counterPlaneChance: 0.25,
};
case 2:
return {
paletteShift: 2,
dailySize: 1.05,
centerJitter: 0.75,
rayLength: 1.1,
rayWeight: 0.9,
rayAngleWobble: 0.55,
orbitRadius: 0.95,
orbiterSize: 1.05,
orbiterShape: 0,
hourStep: 2,
allowTilt: false,
snapDegrees: 45,
shapeFamily: 1,
counterPlaneChance: 0.18,
};
case 3:
return {
paletteShift: 3,
dailySize: 0.88,
centerJitter: 0.65,
rayLength: 0.9,
rayWeight: 1.25,
rayAngleWobble: 0.6,
orbitRadius: 1.1,
orbiterSize: 0.9,
orbiterShape: 1,
hourStep: 2,
allowTilt: true,
snapDegrees: 90,
shapeFamily: 2,
counterPlaneChance: 0.3,
};
case 4:
return {
paletteShift: 0,
dailySize: 1.12,
centerJitter: 1.1,
rayLength: 1.05,
rayWeight: 0.85,
rayAngleWobble: 1.0,
orbitRadius: 0.9,
orbiterSize: 1.1,
orbiterShape: 0,
hourStep: 3,
allowTilt: false,
snapDegrees: 90,
shapeFamily: 0,
counterPlaneChance: 0.12,
};
case 5:
return {
paletteShift: 2,
dailySize: 0.96,
centerJitter: 0.9,
rayLength: 1.15,
rayWeight: 1.0,
rayAngleWobble: 0.8,
orbitRadius: 1.0,
orbiterSize: 1.0,
orbiterShape: 1,
hourStep: 1,
allowTilt: true,
snapDegrees: 45,
shapeFamily: 1,
counterPlaneChance: 0.22,
};
case 6:
return {
paletteShift: 1,
dailySize: 1.0,
centerJitter: 0.55,
rayLength: 0.85,
rayWeight: 1.4,
rayAngleWobble: 0.5,
orbitRadius: 1.15,
orbiterSize: 0.85,
orbiterShape: 0,
hourStep: 4,
allowTilt: false,
snapDegrees: 90,
shapeFamily: 2,
counterPlaneChance: 0.1,
};
default:
return {
paletteShift: 0,
dailySize: 1,
centerJitter: 1,
rayLength: 1,
rayWeight: 1,
rayAngleWobble: 1,
orbitRadius: 1,
orbiterSize: 1,
orbiterShape: 0,
hourStep: 1,
allowTilt: true,
snapDegrees: 90,
shapeFamily: 2,
counterPlaneChance: 0.35,
};
}
}

function snapAngle(angle, snapDegrees) {
const s = snapDegrees || 90;
return Math.round(angle / s) * s;
}

// ----------------------
// Daylight detection
// ----------------------

function refreshDaylightStatus() {
const now = new Date();
const dayKey = `${now.getFullYear()}-${pad2(now.getMonth() + 1)}-${pad2(
now.getDate()
)}`;
lastSunFetchDayKey = dayKey;

if (!navigator.geolocation) {
isDaylight = fallbackIsDaylight(now);
return;
}

navigator.geolocation.getCurrentPosition(
async function (pos) {
try {
const lat = pos.coords.latitude;
const lng = pos.coords.longitude;

const url = `https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lng}&formatted=0`;
const res = await fetch(url, { cache: "no-store" });
const data = await res.json();

if (!data || data.status !== "OK") {
isDaylight = fallbackIsDaylight(now);
return;
}

const sunrise = new Date(data.results.sunrise);
const sunset = new Date(data.results.sunset);

const curMin = now.getHours() * 60 + now.getMinutes();
const sunriseMin = sunrise.getHours() * 60 + sunrise.getMinutes();
const sunsetMin = sunset.getHours() * 60 + sunset.getMinutes();

isDaylight = curMin >= sunriseMin && curMin < sunsetMin;
} catch (e) {
isDaylight = fallbackIsDaylight(now);
}
},
function () {
isDaylight = fallbackIsDaylight(now);
},
{ timeout: 4000 }
);
}

function fallbackIsDaylight(now) {
const h = now.getHours();
return h >= 7 && h < 19;
}

// ----------------------
// Utilities
// ----------------------

function pad2(n) {
return String(n).padStart(2, "0");
}

function pickPalette(seed, offset, shift) {
const s = shift || 0;
const idx = Math.abs((seed + offset * 9973 + s * 131) % CONFIG.palette.length);
return CONFIG.palette[idx];
}

function hash32(str) {
let h = 2166136261 >>> 0;
for (let i = 0; i < str.length; i++) {
h ^= str.charCodeAt(i);
h = Math.imul(h, 16777619);
}
return h >>> 0;
}
})();